diff -up ffmpeg-20080908/libavutil/avutil.h.r15415 ffmpeg-20080908/libavutil/avutil.h
--- ffmpeg-20080908/libavutil/avutil.h.r15415	2008-09-04 22:39:09.000000000 +0200
+++ ffmpeg-20080908/libavutil/avutil.h	2009-03-08 18:24:13.000000000 +0100
@@ -35,7 +35,7 @@
 #define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
 
 #define LIBAVUTIL_VERSION_MAJOR 49
-#define LIBAVUTIL_VERSION_MINOR 10
+#define LIBAVUTIL_VERSION_MINOR 11
 #define LIBAVUTIL_VERSION_MICRO  0
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
diff -up ffmpeg-20080908/libavutil/rational.c.r15415 ffmpeg-20080908/libavutil/rational.c
--- ffmpeg-20080908/libavutil/rational.c.r15415	2007-07-05 12:40:25.000000000 +0200
+++ ffmpeg-20080908/libavutil/rational.c	2009-03-08 18:24:13.000000000 +0100
@@ -101,3 +101,28 @@ AVRational av_d2q(double d, int max){
 
     return a;
 }
+
+int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
+{
+    /* n/d is q, a/b is the median between q1 and q2 */
+    int64_t a = q1.num * (int64_t)q2.den + q2.num * (int64_t)q1.den;
+    int64_t b = 2 * (int64_t)q1.den * q2.den;
+
+    /* rnd_up(a*d/b) > n => a*d/b > n */
+    int64_t x_up = av_rescale_rnd(a, q.den, b, AV_ROUND_UP);
+
+    /* rnd_down(a*d/b) < n => a*d/b < n */
+    int64_t x_down = av_rescale_rnd(a, q.den, b, AV_ROUND_DOWN);
+
+    return ((x_up > q.num) - (x_down < q.num)) * av_cmp_q(q2, q1);
+}
+
+int av_find_nearest_q_idx(AVRational q, const AVRational* q_list)
+{
+    int i, nearest_q_idx = 0;
+    for(i=0; q_list[i].den; i++)
+        if (av_nearer_q(q, q_list[i], q_list[nearest_q_idx]) > 0)
+            nearest_q_idx = i;
+
+    return nearest_q_idx;
+}
diff -up ffmpeg-20080908/libavutil/rational.h.r15415 ffmpeg-20080908/libavutil/rational.h
--- ffmpeg-20080908/libavutil/rational.h.r15415	2008-08-31 09:39:47.000000000 +0200
+++ ffmpeg-20080908/libavutil/rational.h	2009-03-08 18:24:13.000000000 +0100
@@ -113,4 +113,17 @@ AVRational av_sub_q(AVRational b, AVRati
  */
 AVRational av_d2q(double d, int max) av_const;
 
+/**
+ * @return 1 if \q1 is nearer to \p q than \p q2, -1 if \p q2 is nearer
+ * than \p q1, 0 if they have the same distance.
+ */
+int av_nearer_q(AVRational q, AVRational q1, AVRational q2);
+
+/**
+ * Finds the nearest value in \p q_list to \p q.
+ * @param q_list an array of rationals terminated by {0, 0}
+ * @return the index of the nearest value found in the array
+ */
+int av_find_nearest_q_idx(AVRational q, const AVRational* q_list);
+
 #endif /* AVUTIL_RATIONAL_H */
